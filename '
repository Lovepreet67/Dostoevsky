use std::{io::{Read, Write}, net::TcpStream, sync::{Arc,Mutex}, thread::{self, sleep}, time::Duration};

use super::{message::{Message, MessageQueue}, topic::Topic};

pub(super) struct ProducerHandler{
    name:String, 
    stream:TcpStream,
    topics_subscbribed:Vec<Arc<Topic>> 
}  
impl ProducerHandler{ 
    pub fn new(name:String,producer_stream:TcpStream,topic:Vec<Arc<Topic>>)->Self{  
        ProducerHandler {name,stream:producer_stream,topics_subscbribed:topic}   
    }
    pub fn spawn(mut self)->Result<(),std::io::Error>{     
        thread::spawn(move || {
            loop {
                sleep(Duration::from_secs(3));  
                let mut buffer  = [0;256]; //Vec<u8> = Vec::new();      
                let readed_bytes = self.stream.read(&mut buffer).expect("error");  
                if readed_bytes == 0 {   
                    continue; 
                }  
                    //.expect(format!("error while reading the data from producer {}",self.name));        
                println!("readed {} by {}",readed_bytes,self.name); 
                // now we will push the data to the after obtaining the mutex lock on the array
                for topic in &self.topics_subscbribed{
                    let topic_ = Arc::clone(topic); 
                    topic_.new_message(&buffer);
                }              
            }
        });
        Ok(())   
    }
}

pub(super) struct ConsumerHandler{
    id:i32,
    name:String,
    stream:TcpStream,
    topics:Vec<Arc<Topic>>, 
    consumable_index:usize 
}
impl ConsumerHandler { 
    pub fn new(id:i32,name:String,consumer_stream:TcpStream,topics:Vec<Arc<Topic>>)->Self{
        ConsumerHandler{id,name,stream:consumer_stream,topics,consumable_index:0}    
    } 
    pub fn spawn(mut self)->Result<(),std::io::Error>{
        thread::spawn(move || {
                loop {
                    println!("consumer {} (id: {}) is trying to consumer",self.name,self.id);  
                    for &mut topic in self.topics {
                        match topic.get_message(self.consumable_index)  
                        { 
                            Some(buffer)=>{          
                                self.stream.write_all(&buffer).expect("error while writing to the consumer");
                                topic.increment_consumer_count(self.consumable_index); 
                                self.consumable_index+=1;    
                            }
                            None=>{
                                println!("Nothing to consume for consumer : {}",self.name); 
                            }
                        }
                    } 
                    sleep(Duration::from_secs(10)); 
                }
        });
        Ok(()) 
    }

}
